# AWS EC2 Deployment Guide

## The Bootstrap Problem Solution

You encountered the classic Terraform "chicken-and-egg" problem: **You cannot create the S3 bucket for Terraform state within the same configuration that uses that bucket as its backend.**

This guide provides the correct two-step deployment process.

## Step-by-Step Deployment

### Step 1: Bootstrap (Create Backend Infrastructure)

The bootstrap process creates ONLY the S3 bucket and DynamoDB table needed for Terraform state management.

```bash
# Navigate to bootstrap directory
cd bootstrap/

# Run the bootstrap deployment
./deploy-bootstrap.sh
```

This will:
- ✅ Create S3 bucket for Terraform state (with versioning & encryption)
- ✅ Create DynamoDB table for state locking
- ✅ Generate `../backend-config.tf` with the correct backend configuration

### Step 2: Main Infrastructure

After bootstrap completes, deploy the main infrastructure:

```bash
# Go back to main terraform directory
cd ..

# Deploy main infrastructure (now with remote backend)
./deploy-main.sh
```

This will:
- ✅ Initialize Terraform with remote backend
- ✅ Create application backup S3 bucket
- ✅ Complete User Story 1.1 requirements

## What's Different Now?

### Before (Broken)
```
terraform/
├── backend.tf          # ❌ Created state bucket AND used it as backend
├── main.tf             # ❌ Circular dependency
└── deploy-backend.sh   # ❌ Tried to do everything at once
```

### After (Fixed)
```
terraform/
├── bootstrap/          # ✅ Creates backend infrastructure ONLY
│   ├── main.tf
│   ├── backend.tf      # Creates S3 + DynamoDB
│   └── deploy-bootstrap.sh
├── backend.tf          # ✅ Only application resources
├── backend-config.tf   # ✅ Generated by bootstrap
├── main.tf             # ✅ Uses remote backend
└── deploy-main.sh      # ✅ Deploys with remote state
```

## Directory Structure

```
iac/aws/ec2/terraform/
├── bootstrap/                    # Bootstrap infrastructure
│   ├── main.tf                   # Provider configuration
│   ├── variables.tf              # Bootstrap variables
│   ├── backend.tf                # S3 + DynamoDB resources
│   ├── outputs.tf                # Backend config generation
│   └── deploy-bootstrap.sh       # Bootstrap deployment script
├── main.tf                       # Main provider configuration
├── variables.tf                  # Main variables
├── backend.tf                    # Application resources (S3 backups)
├── outputs.tf                    # Application outputs
├── backend-config.tf             # Generated backend config
├── deploy-main.sh                # Main deployment script
└── README.md                     # This guide
```

## Verification

After both steps complete, verify the setup:

```bash
# Check Terraform state location
terraform state list

# Should show resources managed in remote S3 backend
# State is now stored in: s3://xpress-erpnext-terraform-state-XXXX/terraform.tfstate
```

## Troubleshooting

### If Bootstrap Fails
```bash
cd bootstrap/
terraform destroy
# Fix the issue, then run ./deploy-bootstrap.sh again
```

### If Main Deployment Fails
```bash
# From main directory
terraform destroy
# Fix the issue, then run ./deploy-main.sh again
```

### Clean Slate Reset
```bash
# Destroy main infrastructure
terraform destroy

# Destroy bootstrap infrastructure
cd bootstrap/
terraform destroy

# Remove generated files
cd ..
rm -f backend-config.tf

# Start over with Step 1
```

## Why This Approach Works

1. **Bootstrap** creates the backend infrastructure with LOCAL state
2. **Main** infrastructure uses REMOTE state from the bootstrap-created backend
3. **No circular dependencies** - clean separation of concerns
4. **Best practice** - follows HashiCorp's recommended approach

---

**Status**: ✅ **Ready for deployment**
**Next**: Continue with User Story 1.2 (VPC networking)
